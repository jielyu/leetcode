
/*
#LeetCode# Q0064 最小路径总和
难度：中

给定一个由非负数组成的m x n网格，从左上角到右下角，找出一条从左上角到右下角的路径，使所有数字之和最小化。

注意：在任何时间点上，你只能向下或向右移动。

Example:

Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.

*/
#include "leetcode.h"

namespace q0064
{

template<typename T>
bool run_testcases() {
    T slt;

    return true;
}

class Solution {
public:
    void func();
};

} // namespace q0064
